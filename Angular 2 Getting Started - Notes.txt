
In the root folder of the project (where the project.json file is), 
 + Run "npm install" in to install all the dependencies.
 + Run "npm start" to fun the start script which start the server and add watch mode for code changes to see the changes immediately 

By convention the root component of an application is named AppComponent

Modules (export, import)will be automatically added to the index.html file with SystemJS

+++ To create an Angular2 component +++
import { Component } from 'angular2/core'; 	// load Component function from angular core module
@Component({
	selector: 'pm-app', 	// defines a component's directive name, which can be used like a tag in the html (ex: "<body><pm-app></pm-app></body>")
	template: '<h1>Hello {{name}}</h1>' 	// a component must have a template which displays html on the page
})
export class AppComponent{
	name: string = "Tai Le"
}


+++ To use url for the template +++
@Component({
    selector : 'pm-products',
    templateUrl : 'app/products/product-list.component.html' 		// Use templateUrl instead of template
})


+++ To use a component as a directive inside another component
1) Add the directive of the component we want to use inside of outter component's template
2) Add the component name to the the 'directives' array of @Component 
3) Import the component
Ex:
import { ProductListComponent} from './products/product-list.component' 	// (1)
@Component({	
	selector : 'pm-app',
	template: '<div><pm-products></pm-products</div>' 						// (2)
	directives: [ProductListComponent]										// (3)
})

+ Property binding - one way binding, from the component class's property to the target element's property
Ex: <img [src]='product.imageUrl'> 		// property binding
	<img src={{product.imageUrl}}> 		// interpolation
	
	
+ Event binding - binds a event to an expression, often the component's method
Ex: <button (click)='toggleImage()'>  	// notice events use (), whereas properties use []	

+ Two-way binding 
Ex: <input [(ngModel)]='listFliter'>

+ Pipes tranform bound properties before they're displayed

+ Define an interface to specify custom types. Import the interface to use it
Ex: 
export interface IProduct{
	productId: number;
	productName: string;
	calculateDiscount(percent: number): number;
}
	
+ To encapsulate component styles (this will apply to the component's template and won't leak out to other parts of the application)
@Component({
	selector: 'pm-product',
	templateUrl: 'app/products/product-list.component.html',
	styles: ['thead {color: #337AB7;}'] 					// styles
})	

@Component({
	selector: 'pm-product',
	templateUrl: 'app/products/product-list.component.html',
	styleUrls: ['app/products/product-list.component.css']  // using style sheets
})

+ To use Angular's lifecycle hooks, implement the component with Angular's lifecycle interfaces: OnInit, OnChanges, and OnDestroy
Ex:
import { Component, OnInit } from 'angular2/core';
@Component({
	...
})
export class ProductListComponent implements OnInit{
	pageTitle: string = 'Product List';
	ngOnInit(): void{
		console.log('In OnInit');
	}
}


+ To build custom pipe 
import { Pipe, PipeTransform } from 'angular2/core' 	
@Pipe({	
	name: 'productFilter'	// name of the pipe used in the template					
})
export class ProductFilterPipe implements PipeTransform{
	transform(value: IProduct[], args: string[]) : IProduct(){  
	
	}
	
} // 'value' is the array the gets passed in, 'args' is the arguments we use to perform the tranformation

+ To use the custom pipe
import { ProductFilterPipe } from './product-filter.pipe'; 
@Component({
	selector: 'pm-product',
	templateUrl: 'app/products/product-list.component.html',
	pipes: [ProductFilterPipe]
})
export class ProductListComponent{}


+ For nested component
 - Use Input decorator on the property in the nested component class that wants the value passed from parent component
 export class StarComponent{
	@Input() rating: number;
	starWidth: number;
 }
 - To pass the value to nested component, use property binding
 <ai-star [rating]='product.starRating'></ai-star>
 
 - To pass data from nested component to parent component, use the decorator Output on an event property
 Inside the nested component:
 export class StarComponent{
	@Input() rating: number;
	@Output() notify: EventEmitter<string> = new EventEmitter<string>();
	
	onClick(){
		this.notify.emit("clicked!");		// when user click the stars, emit the event to parent component
	}
 }
 Inside the parent component's html
  <ai-star [rating]='product.starRating'	// this is from parent to nested
	(notify)='onNotify($event)'				// this is from nested to parent
  ></ai-star>
 Inside the parent component:
 export class ProductListComponent{
	onNotify(message: string): void{} 		// handle the event
 }
 
 
 
 
 
 